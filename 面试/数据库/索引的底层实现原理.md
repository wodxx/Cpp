# 数据库索引底层数据结构

>索引是一种数据结构

得分点： **数据库的底层数据结构为B+树！**

## 索引可选的底层数据机构包括

- 二叉树

- 红黑树

- hash

- B-tree

但Mysql索引的底层用的并不是二叉树和红黑树。

## B-Tree(多路平衡查找树)

>度：一个节点的子节点的个数

B树的一个节点可以有多个子节点，比如有4个子节点，称为5阶B树，即每个节点最多拥有4个子节点(key),5个指针。

## Hash

哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后储存在hash表中。

>hash冲突：如果多个键值映射到一个相同的槽位上，他们就产生了hash冲突，可以通过链表来解决。(在冲突的键值后面用指针链上另外的键)

特点：

- 只能用于对等比较(=, in),不支持范围查询(between, >, <,...)

- 无法利用索引完成排序操作

- 查询效率高，通常只需要依次检索就可以，效率高于B+树

在Mysql中，支持hash索引的时Memory引擎，而InnoDB中具有自适应hash功能。

## 使用B+树的原因

### B+树的由来

- 而**B+树由B树和索引顺序访问方法演化而来，它是为磁盘或其他直接存取辅助设备设计的一种平衡查找树**

- **在B+树中，叶子节点形成了一个单向链表，每一个节点的指针都指向下一个节点**。B+树为所有叶子节点增加了链接，从而实现了快速的范围查找(即所有的非叶子节点都会出现在叶子节点一层)

- 为了减少磁盘IO的次数，必须降低树的深度，因此在**二叉查找树基础上将树改成了多叉加上一些限制条件，就形成了B树**(B树的由来)；

![如下图](https://uploadfiles.nowcoder.com/images/20220226/4107856_1645862987121/3CF9D9131AE159CAE89F36798645787C)

### B+树的优点

- B+树索引在数据库中的一个特点就是高扇出性，例如在InnoDB存储引擎中，每个页的大小为16KB。在数据库中，B+树的高度一般都在2～4层，这也就是说查找某一键值的行记录时最多只需要2到4次 IO。这很不错，因为当前一般的机械磁盘每秒至少可以做100次IO，2～4次的IO意味着查询时间只需0.02～0.04秒(查询效率高)。

- B+树中，叶子节点形成了一个双向链表，**便于范围搜索和排序**。

- 在数据库中，**B+树索引还可以分为聚集索引和辅助索引**，但不管是聚集索引还是辅助索引，其内部都是B+树的，即高度平衡的，叶子节点存放着所有的数据。聚集索引与辅助索引不同的是，叶子节点存放的是否是一整行的信息。(B+树的分类)

## 为什么用B+树而不用红黑树或者二叉树

因为二叉树和红黑树在某些场景下都会暴露出一些缺陷。

- 首先，**二叉树**在某些场景下会退化成链表，而链表的查找需要从头部开始遍历，而这就失去了加索引的意义(二叉树顺序插入时会形成一个链表，**查询性能大大降低**。大数据量的情况下，层级较深，**检索速度慢**)

- 其次，解决二叉树在顺序插入时会形成链表这个弊端，可以使用红黑树(**红黑树一种自平衡的二叉树**)。但仍然会在大数据量下使得树的层级较深。

- 最后，不使用**红黑树**的原因是：红黑树作为底层数据结构在面对大数据量的场景时，会导致索引树的**层数很高**。索引从根节点开始查找，而如果我们需要查找的数据在底层的叶子节点上，那么树的高度是多少，就要进行多少次查找，数据存在磁盘上，访问需要进行**磁盘IO**，这会导致**效率过低**；同理，二叉树的存储结构也存在着这种问题。

## 为什么用B+树，不用哈希表

- MySQL中的索引B+树实现的

- 哈希表的查询效率的确最高，时间复杂度O(1)，但是它**要求将所有数据载入内存**，而数据库存储的数据量级可能会非常大，全部载入内存无法实现

- B+树是N叉数，树的高度低，能够有效减少磁盘IO读写，提高检索效率

- 相对于Hash操作，B+树支持范围匹配及其排序操作
