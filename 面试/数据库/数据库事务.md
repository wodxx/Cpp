# 数据库事务

## 概念理解

事务：所谓事务，就是要完成一件事情，在这个事情中包含了多个任务

    当所有的任务都执行成功，这个事情就是成功的：所有改动的数据生效

    当任意一个任务执行失败，这个事情就是失败的：所有改动的数据回退

对于事务的管理操作：称为事务管理

术语解释：事务（txn）是一系列在共享数据库上执行的行为，以达到更高层次更复杂逻辑的功能。

    开启事务：[开始记录一个事情中的多个任务]

    执行事务SQL语句：[正常情况下，一条语句就是一个任务]

    提交事务：【成功】| 回滚事务【事务】

事务管理关键词

    开启事务：start transaction | begin | set autocommit = 0

    执行SQL语句à 多条SQL语句

提交事务Commit | 回滚事务 Rollback

案例操作：监察部门 | 老曾

    增加一个部门：SQL

    增加一个员工：SQL

```sql

# ----------------------------------------------
SELECT * FROM dept; -- 部门表

SELECT * FROM emp; -- 员工表

# -- 下面的两条SQL语句接受事务管理：必须同时成功 提交数据；否则数据还原

# start transaction;# 开启事务

BEGIN

INSERT INTO dept(dname, darea, dreg_time, ddesc)

  VALUES('监察', 'DSJ102', '2018-08-29 00:00:00', '学生建设、教学质量监管');

INSERT INTO emp(NAME, age, pid, reg_time, dept_id)

  VALUES('老曾', 34, 4, '2018-08-29 00:00:00', 10);

COMMIT; # 提交事务

ROLLBACK; # 回滚事务
```

## 事务的特性--ACID

ACID，是指在可靠数据库管理系统（DBMS）中，事务(transaction)所应该具有的四个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。

### 原子性（Atomicity）

原子性是指事务是一个不可再分割的工作单位，事务中的操作要么都发生，要么都不发生。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。

假设A要给B转钱，在事务中的扣款和加款两条语句，要么都执行，要么就都不执行。否则如果只执行了扣款语句，就提交了，此时突然断电，A账号已经发生了扣款，B账号却没收到加款，在生活中就会引起纠纷。

### 一致性（Consistency）

一致性是指事务使得系统从一个一致的状态转换到另一个一致状态。这是说数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。

对银行转帐事务，不管事务成功还是失败，应该保证事务结束后ACCOUNT表中A和B的存款总额始终为2000元。如果一个人扣100元，一个人得50元，就破坏了一致性。

### 隔离性（Isolation）

多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。

这指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。由并发事务所做的修改必须与任何其他并发事务所做的修改隔离。

并行时可能出现的问题：

- 脏读：事务A修改了一个数据，但未提交，事务B读到了事务A未提交的更新结果，如果事务A提交失败，事务B读到的就是脏数据。

- 不可重复读：在同一个事务中，对于同一份数据读取到的结果不一致。比如，事务B在事务A提交前读到的结果，和提交后读到的结果可能不同。

- 幻读：在同一个事务中，同一个查询多次返回的结果不一致。事务A新增了一条记录，事务B在事务A提交前后各执行了一次查询操作，发现后一次比前一次多了一条记录。

不同的隔离级别：

- Read Uncommitted：最低的隔离级别，什么都不需要做，一个事务可以读到另一个事务未提交的结果。所有的并发事务问题都会发生。

- Read Committed：只有在事务提交后，其更新结果才会被其他事务看见。可以解决脏读问题。

- Repeated Read：在一个事务中，对于同一份数据的读取结果总是相同的，无论是否有其他事务对这份数据进行操作，以及这个事务是否提交。可以解决脏读、不可重复读。

- Serialization：事务串行化执行，隔离级别最高，牺牲了系统的并发性。可以解决并发事务的所有问题。

### 持久性（Durability）

持久性，意味着在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

即使出现了任何事故比如断电等，事务一旦提交，则持久化保存在数据库中。

## 为什么会有数据库

早期的时候，编程主要是科学家用于科学计算，他们对编程很熟练，**数据直接存在文件系统中**(硬盘里)，自己随心所欲定义数据的格式，然后自己写程序读入数据，再写下一些对输入输出的说明给别人看。大概就是这种感觉（事实上可能复杂得多，现在这种文件的数据管理和编程方式依然广泛应用于物理、化学等理科，以及部分计算机的场景中）

后来，很多商业公司也想用数据库来做数据管理和分析，**这种类似文件的管理方式，不适合大规模数据的管理和共享**，能够统一管理和共享数据的 数据库管理系统（DBMS） 应运而生。**数据库设计的核心是数据模型的定义，也即我们如何去组织管理数据，更有利于数据的开发和利用**

再后来，数据的作用越来越大，数据分析逐渐成为了一项专门的服务，数据库也在与时俱进，在数据存储以外，集成了越来越多的**数据管理与分析的功能**，让数据分析与数据科学变成了一般人员可以**低成本学习与操作的事务**（SQL的出现）。不然，**面对海量的数据直接存放在磁盘上，而没有数据库的话**，对于一个分析师来说仅仅搞明白这些数据的读取方式就够呛了，如果数据要进行增删查改，还得自己去思考数据的管理方式，编程实现数据的搜索、筛选、去重等很常见的基础功能，**如果数据发生一些变化，编程上可能也得相应进行很多修改，实在是不够便捷**。

- 数据库将零散的数据管理起来，**让数据变得结构化，易于后续的数据分析**，数据不再是平铺的，而是有结构的了。

- 数据库隐藏了**数据底层存储方式的细节，用一种统一的方式**向上层应用供给数据，让数据的简单存取变成现实。
对于存储方式的细节可以举一个例子，比如分布式数据库，对应着上一篇文章中提到的“如果不同房间可以连通，那么不同房间的柜子可以一起存东西，就像只有一个柜子一样”。数据实际上是分块存储在不同的机器中，但通过网络可以连成一个集群，对外提供统一的数据库服务，使用起来依然就像数据在一台机器上，这样就大大方便了数据的管理。

- 由于标准的统一，**数据的共享和交流变得方便**，大家遵循同样的方式去使用和管理数据，对数据的抽象和描述变得简单。

- 数据库一般都**提供了并发和网络的功能，可以同时支撑多个用户使用数据**，可以支持数据的远程访问，从此数据不需要存放在本地，比如在北京可以通过数据库来访问远在伦敦和纽约的数据，推动了数据的共享和可用。

- 数据库是**支撑大数据的基石，提供了较为完善的数据分析功能**，极大地降低了数据科学的门槛，让数据分析不再是几百条几千条数据的规模，直接上升到TB、PB级别的规模。

- 数据库还是数据安全的保护伞，**提供了数据的备份与恢复功能**。可以试想一下，当你在写你的论文时，电脑忽然断电了，你最为担心的是什么？是office软件的安全吗？当然不是，你担心的是你的论文数据还在不在。

- **数据库提供了这样的功能，保障了数据的持久性（Durability），如果程序突然挂掉**，数据库有数据恢复机制来保障数据的安全。即便极端一点，这台计算机被外力摧毁（例如战争、地震），数据库一般也有容灾备份的机制，数据存储在多个地方，可以迅速恢复。

