# 虚函数实现多态原理

## 1、C++中如何实现多态

- 基类中先声明一个虚函数

- 至少有一个继承该基类的子类

## 2、虚函数实现多态的原理

- 当一个类中出现虚函数或着子类继承了虚函数时，就会在该类中产生一个虚函数表（virtual table），虚函数表实际上是一个函数指针数组（在有的编译器作用下是链表），里面的每一个元素对应指向该类中的某一个虚函数的指针。被该类声明的对象会包含一个虚函数表指针（virtual table pointer），指向该类的虚函数表的地址。

![虚函数](https://img-blog.csdnimg.cn/20210530004500302.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY5MzYyNQ==,size_16,color_FFFFFF,t_70#pic_center)

- 虚函数的调用过程： 当一个对象要调用到虚函数时，先将对象内存中的vptr指针（虚函数表指针）指向定义该类的vtbl（虚函数表），vtbl再寻找里面的指针指向想要调用的虚函数，从而完成虚函数的调用。

### 2.1 单类继承

- 定义一个父类

```C
class Person{
public:
  virtual void f(){cout << "use f()" << endl;}
  virtual void g(){cout << "use g()" << endl;}
  virtual void h(){cout << "use h()" << endl;}
};
```

父类对象其在内存中布局如下：

![fulei](https://img-blog.csdnimg.cn/20210530231715795.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY5MzYyNQ==,size_16,color_FFFFFF,t_70#pic_center)

```C
class Bag:public Person{
public:
  virtual void i(){cout << "use i()" << endl;}
  virtual void j(){cout << "use j()" << endl;}
};
```

![Bag类内存](https://img-blog.csdnimg.cn/20210530231736156.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY5MzYyNQ==,size_16,color_FFFFFF,t_70#pic_center)

可以看出虚函数表内的虚函数是按声明顺序进行排序的

父类虚函数排在子类虚函数之前

- 当我们把子类中的虚函数覆盖掉：（修改Bag类）

```C
class Bag:public Person{
public:
  void f(){cout << "class Bag use fun" << endl;}
  virtual void i(){cout << "use i()" << endl;}
  virtual void j(){cout << "use j()" << endl;}
}; 
```

![](https://img-blog.csdnimg.cn/20210530231801182.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NDY5MzYyNQ==,size_16,color_FFFFFF,t_70#pic_center)

子类覆盖的虚函数，放在父类原先放该虚函数的位置上。所以当父类指针指向该子类对象时，会调用该子类的重载函数

### 2.2 多类继承

[参考1](https://blog.csdn.net/weixin_44693625/article/details/117393578?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166065110716782414929127%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=166065110716782414929127&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-4-117393578-null-null.142^v41^pc_rank_34_2,185^v2^control&utm_term=%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8C%E8%99%9A%E5%87%BD%E6%95%B0&spm=1018.2226.3001.4187)

[参考2](https://blog.csdn.net/qq_24309981/article/details/89102183?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522166065110716782414929127%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=166065110716782414929127&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-3-89102183-null-null.142^v41^pc_rank_34_2,185^v2^control&utm_term=%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%8C%E8%99%9A%E5%87%BD%E6%95%B0&spm=1018.2226.3001.4187)

## 问题

### 4 构造函数可以声明为虚函数吗？

显然构造函数是不能声明为虚函数的。

我们知道，在调用虚函数前，需要先访问虚表指针，得到虚表，然后再执行虚表中相对应的函数。假设，现在将构造函数声明为虚函数：调用构造函数时，发现构造函数是一个虚函数，然后去访问虚表指针，可是虚表指针是在构造函数中进行初始化的，而目前构造并没有执行，也就是说，虚表指针还没有初始化，只是一个空值，理所当然的，也就找不到指向构造函数的函数指针，因此无法完成构造函数的调用。可见，构造函数是不能声明为虚函数的。

### 5 析构函数可以声明为虚函数吗？

1、当然是可以的，而且，为了防止内存泄漏，基类的析构函数必须声明为虚函数！

2、为什么将基类析构函数声明为虚函数，就可以防止内存泄漏？

- 如果没有将基类析构函数声明为虚函数，在释放指向派生类对象的基类指针的时候，只会调用基类的析构函数，而派生类的析构函数不会被调用，导致属于派生类的新添加的数据得不到释放，从而导致内存泄漏。

- 如果将析构函数声明为虚函数，在释放指向派生类对象的基类指针的时候，会调用派生类的析构函数，而派生类的析构函数会自动调用基类的析构函数，从而释放所有内存，避免了内存泄漏。

3、可是，有个问题，为什么将基类析构函数声明为虚函数之后，在释放指向派生类对象的基类指针时，调用的是派生类的析构函数？难道派生类的析构函数重写了基类的析构函数？不可能啊，基类析构函数和派生类析构函数的函数名不同，不能构成重写啊。

- 其实，析构函数是一个特殊的函数，编译器在编译时，析构函数的名字统一为destucter；

- 所以只要将基类的析构函数声明为虚函数，不管子类的析构函数前是否加virtual，都构成重写。这也就可以解释为什么将基类析构函数声明为虚函数，释放指向派生类对象的基类指针时，会调用派生类的析构函数，因为虚表中的函数指针指向的是派生类的析构函数。

[参考3](https://blog.csdn.net/lihao21/article/details/50688337)

[参考4](https://blog.csdn.net/han8040laixin/article/details/81704165)
