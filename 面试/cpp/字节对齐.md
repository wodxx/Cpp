# 内存字节对齐

## 什么是内存字节对齐

现代计算机中内存空间都是按照 字节（byte）划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但是实际的计算机系统对基本类型数据在内存中存放的位置有限制，它们会要求这些数据的首地址的值是某个数 k（通常它为4或8）的倍数，这就是所谓的内存对齐。

## 为什么要字节对齐？

为了使CPU能够对变量进行快速的访问，变量的起始地址应该具有某些特性，即所谓的”对齐”，比如4字节的int型，其起始地址应该位于4字节的边界上，即起始地址能够被4整除，也即对齐跟数据在内存中的位置有关。如果一个变量的内存地址正好位于它长度的整数倍，他就被称做自然对齐。

写一个结构体，然后求sizeof，其结果往往比声明的变量的总长度要大。

>关于每个变量所占的字节数，64编译器环境下如下

|bool | char|short|int|long|float|long int|long long|double|long double|
|- | - | - | -|-|-|-|-|-|-|
|1|1|2|4|4|4|4|8|8|16|

## 字节对其规则

- **结构体中每个变量需在不超过系统默认字节对齐数的条件下满足自身对齐的要求，且整个结构体也需满足对齐规则**

关于对齐规则，记住下面的条件就好了。

- 条件①：结构体当前大小 % **当前变量自身有效对齐字节数** = 0，如果无法对齐，则持续填充字节直至对齐。(对一个变量)

- 条件②：结构体的总大小 % **结构体最大对齐字节数** = 0，如果无法对齐，则持续填充字节直至对齐。(对整个结构体)

## 简单结构体变量对齐

### 示例1

```C
struct A{
    int    a;
    char   b;
    short  c;
};
```

![daan](https://img-blog.csdnimg.cn/855880506d524a588231ef4a0459c1ec.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6K-35Y-r5oiR5Z2k5ZOl,size_17,color_FFFFFF,t_70,g_se,x_16)

解析如下：

当前变量|自身对齐字节数|系统默认字节对齐数|自身有效对齐字节数|对齐前所占总字节数|字节对齐需填充字节数|对齐后所占总字节数
|-|-|-|-|-|-|-|
a|4|16|min(4,16)=4|0|0|4
b|1|16|min(1,16)=1|4|0|5
c|2|16|min(2,16)=2|5|1|8

1、当前结构体大小为0，当前int变量自身有效对齐数为4，满足条件①0%4=0，结构体大小0+4=4；

2、第二个char变量自身有效对齐数为1，当前结构体大小为4。满足条件①4%1=0，结构体大小4+1=5；

3、第三个short变量自身有效对齐数为2，当前结构体大小为5，不满足条件①5%2=0，故填充一个字节。现在6%2=0，满足条件，结构体大小6+2=8；

4、结构体总字节大小为8=(4+1+1+2)，满足条件②8%4=0

5、得出结果结构体A占8字节；

存储结构大致示意如下：

|int|int|int|int|char|XXX|short|short|

### 示例2

```C
struct B{
    char   b;
    int    a;
    short  c;
};
```

![tushi](https://img-blog.csdnimg.cn/c74ef8e8d68a4d98be3ec1f7f5fd8b46.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA6K-35Y-r5oiR5Z2k5ZOl,size_17,color_FFFFFF,t_70,g_se,x_16)

解析如下：

当前变量|自身对齐字节数|系统默认字节对齐数|自身有效对齐字节数|对齐前所占总字节数|字节对齐需填充字节数|对齐后所占总字节数
|-|-|-|-|-|-|-|
a|1|16|min(1,16)=1|0|0|4
b|4|16|min(4,16)=4|1|3|8
c|2|16|min(2,16)=2|8|0|10

1、第一个char变量满足条件①0%1=0，结构体大小0+1=1；

2、第二个int不满足条件①1%4=0，故填充3个空字节。现在4%4=0满足条件，当前结构体大小4+4=8；

3、第三个short满足条件8%2=0，当前结构体大小8+2=10；

4、结构体总字节大小为10(1+3+4+2)不满足条件②10%4=0，故添加两个空字节，现在12%4=0满足条件②；

5、得出结构体B占12字节；

存储结构大致如下：
|char| XXX | XXX | XXX |int| int | int | int |short| short| short| short|

## 还有带数组的结构体内存对齐

[参考](https://blog.csdn.net/x2528238270/article/details/120798606?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-120798606-blog-4084088.pc_relevant_multi_platform_whitelistv5&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-120798606-blog-4084088.pc_relevant_multi_platform_whitelistv5&utm_relevant_index=2)
