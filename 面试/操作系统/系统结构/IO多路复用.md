# I/O多路复用

【标准回答】

I/O 多路复用是**一个线程处理多个连结请求的过程和技术**，从而提高程序的性能。I/O 多路复用能够在单个线程中，通过监视多个 I/O 流的状态来同时管理多个 I/O 流，一旦检测到某个文件描述符合我们关心的事件发生（就绪），能够通知程序进行相应的处理（读写操作）。

## Linux 下实现 I/O 复用的系统调用主要有 select、poll 和 epoll

### epoll原理

**得分点** epoll_create、epoll_ctrl、epoll_wt、红黑树、双向链表、epoll的两种工作模式 标准回答 epoll 是一种更加高效的 I/O 复用技术，epoll 的使用步骤及原理如下：

1. 调用 epoll_create() 会在内核中创建一个 eventpoll 结构体数据，称之为 epoll 对象，在这个结构体中有 2 个比较重要的数据成员，一个是需要检测的文件描述符的信息 struct_root rbr（红黑树），还有一个是就绪列表struct list_head rdlist，存放检测到数据发送改变的文件描述符信息（双向链表）；

2. 调用 epoll_ctrl() 可以向 epoll 对象中添加、删除、修改要监听的文件描述符及事件；

3. 调用 epoll_wait() 可以让内核去检测就绪的事件，并将就绪的事件放到就绪列表中并返回，通过返回的事件数组做进一步的事件处理。 epoll 的两种工作模式：

4. LT 模式（水平触发） LT（Level - Triggered）是缺省的工作方式，并且同时支持 Block 和 Nonblock Socket。在这种做法中，内核检测到一个文件描述符就绪了，然后可以对这个就绪的 fd 进行 IO 操作，如果不作任何操作，内核还是会继续通知。

5. ET 模式（边沿触发） ET（Edge - Triggered）是高速工作方式，只支持 Nonblock socket。在这种模式下，当描述符从未就绪变为就绪时，内核通过 epoll 检测到。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了。但是请注意，如果一直不对这个 fd 进行 IO 操作（从而导致它再次变成未就绪），内核不会发送更多的通知（only once）。 ET 模式在很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。epoll 工作在 ET 模式的时候，必须使用非阻塞套接口，以避免由于一个文件描述符的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。

### select 的主旨思想

- 首先要构造一个关于文件描述符的列表，将要监听的文件描述符添加到该列表中，这个文件描述符的列表数据类型为 fd_set，它是一个整型数组，总共是 1024 个比特位，每一个比特位代表一个文件描述符的状态。比如当需要 select 检测时，这一位为 0 就表示不检测对应的文件描述符的事件，为 1 表示检测对应的文件描述符的事件。

- 调用 select() 系统调用，监听该列表中的文件描述符的事件，这个函数是阻塞的，直到这些描述符中的一个或者多个进行 I/O 操作时，该函数才返回，并修改文件描述符的列表中对应的值，0 表示没有检测到该事件，1 表示检测到该事件。函数对文件描述符的检测的操作是由内核完成的。

- select() 返回时，会告诉进程有多少描述符要进行 I/O 操作，接下来遍历文件描述符的列表进行 I/O 操作。 select 的缺点：

1. 每次调用select，都需要把 fd 集合从用户态拷贝到内核态，这个开销在 fd 很多时会很大；

2. 同时每次调用 select 都需要在内核遍历传递进来的所有 fd，这个开销在 fd 很多时也很大
3. select 支持的文件描述符数量太小了，默认是 1024（由 fd_set 决定）；

4. 文件描述符集合不能重用，因为内核每次检测到事件都会修改，所以每次都需要重置；

5. 每次 select 返回后，只能知道有几个 fd 发生了事件，但是具体哪几个还需要遍历文件描述符集合进一步判断。

### poll 的原理

**poll 的原理和 select 类似，poll 支持的文件描述符没有限制。**

poll底层使用的是链表

## select poll epoll

### 背景

当使用服务器服务多个client的时候很常见的方案是给每一个client开一个线程。

随着client的数量越来越多就会造成非常大的开销（线程切换等）

所以**使用I/O多路复用技术（一个线程）来监听多个文件描述符(fd)，来告诉服务端哪个文件描述符已经准备就绪，可以进行操作了**。

[I/O复用解决的办法：]

- 多个网络I/O附用一个线程或多个线程来处理请求

- 线程不需要等待事件被触发，而当I/O事件被触发时能直接通知应用程序

- 网络连结在中间层上进行注册，程序也需要阻塞在这个中间层上，等待事件通知，这个中间层就是select，epoll，poll。

### select

select调用以下函数：

通过select可以监听多个通道，不会因为其中一个通道的阻塞影响到其他通道的正常读写

```C
  int select(int fd, fd_set* readfds, fd_set* writefds, fd_set exceptfds, struct timeval* timeout);
  返回: 若有就绪描述符则为其数目，若超时则位0，若出错则为-1
```

readfds、writefds、exceptfds分别代表了读、写、异常的事件的文件描述符集合。

readfds 准备好可以进行读的文件描述符集合

writefds 可以写的文件描述符集合

excepfds 监控是否发生异常

fd_set 是一个结构体，结构体包括一个整型数组，具体fd_set大小由fd_setsize来决定

优缺点：select默认最大只支持1024个文件描述符，可以通过FD_SETSIZE来进行调整；缺点是fd数量被限制，内部存储结构所决定的对socket扫描时线性扫描，效率较低

因为select技术要对它所监听的fd要进行轮迅才能直到哪个客户端要进行交互，才告诉系统去进行操作

### poll

采用链表的数据结构

每个pollfd都可以表示监听事件。

每个pollfd结构体中的events用来表示文件描述符上被监听的事件

优缺点：

解决了文件描述符上限的问题，也避免了一些文件描述符过大而造成的问题

轮训的时候也不需要轮训到最大描述符+1的位置

### epoll

epoll的三个调用：

```C
  epoll_create()  // 创建句柄，创建红黑树(查询属于log级别，效率较其他数据结构高)
  epoll_ctrl()   // 管理红黑树中的文件描述符
  epoll_wait()   // 等待epoll中文件描述符上事情发生的调用
```

之前的create可以穿入size参数来控制文件描述符集合大小的上限
