# 位移运算

## 已知

1. 二进制整数最终都是以补码的形式呈现的。正数的最高位是0，负数的最高位是1。正数的原码，补码，反码都一样。负数的反码为原码取反，补码为反码加1。

2. 位移运算有两种，一种是带符号位移运算一种是不带符号位移运算。

## 带符号的位移运算(<<与>>)

带符号位移运算分为<<(左移)与>>(右移)。**这两种位移，都是针对补码运算，符号位均参与位移运算**，右移除负数往高位补1之外，其余位置都补0,而左移不管是正数还是负数，空位都补0，所以左移过程中，负数有可能变成正数，正数有可能会变成负数。

不分正负：针对偶数一般右移一位就是除2,左移一位是乘2，针对奇数，右移一位就是除2-1，减一因为多余一位被直接抹除了，左移一位也是乘2。示例：

35

原码：00100011                     >>1(补码右移一位)：00010001=17（2的0次方+2的4次方）
补码：00100011                     <<1(补码左移一位)：01000110=70
反码：00100011

-35(负数)

负数比较特殊，这里来特殊说明一下：

(1)首先说明原码：

35的原码我们知道是00100011，所以-35的原码是10100011(最高位是符号位，负数的符号位是1，其余位跟正数是一样的)。

(2)再说反码：

负数的反码是负数的原码取反，所以-35的反码为11011100(高位仍然不变，负数一直是1，其他取反)。

(3)再说补码：

负数的补码是反码加一，所以-35的补码是11011101。所以:

“>>1”(补码右移一位)=11101110(负数右移，高位补1)，转成原码=10010010(补码减一，然后取反)= -18

“<<1”(补码左移一位)=10111010,转成原码= 11000110= -70

## 不带符号位移运算,只有右移运算（>>>），不存在左移运算

[参考](https://blog.csdn.net/zhaozhiwen6140/article/details/99335892?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165075879916781683965142%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165075879916781683965142&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-99335892.142^v9^pc_search_result_control_group,157^v4^control&utm_term=%E4%BD%8D%E7%A7%BB%E8%BF%90%E7%AE%97&spm=1018.2226.3001.4187)

