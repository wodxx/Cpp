# 排序算法小结

>常用排序算法总结和对比

![总结图](https://img-blog.csdnimg.cn/img_convert/40aaaed1ed918aa4303290dc8c3f3e2b.png)

## 快速排序

### 快速排序算法的基本思想是

- 从数组中取出一个数，称之为基数（pivot）

- 遍历数组，将比基数大的数字放到它的右边，比基数小的数字放到它的左边。遍历完成后，数组被分成了左右两个区域(第一次遍历完成找到了基数的位置)

- 将左右两个区域视为两个数组，重复前两个步骤，直到排序完成

### 代码实现

```C++
#include <bits/stdc++.h>
using namespace std;

const int N = 100010;
int n;
int nums[N];

void quickSort (int nums[], int left, int right) {
  if (left >= right) return;                             // 区间里面只有一个数或者没有数

  int mid = nums[(left + right) / 2];                    // 选取的基数（分割区间的标记数）
  int i = left - 1;                                      // 区间的两端 各向左、向右移动一位
  int j = right + 1;

  while (i < j) {
    do(i++); while (nums[i] < mid);                      // 这两各do-while 循环不动了说明前面的大于基数且后面的小于基数
    do(j--); while (nums[j] > mid);
    if (i < j) swap (nums[i], nums[j]);                  // 开始执行前后交换
  }

  quickSort(nums, left, j);
  qucikSort(nums, j + 1, right);
}

int main () {
  cin >> n;
  for (int i = 0; i < n; i++) cin >> nums[i];
  quickSort(nums, 0, n - 1);                             // 给快排函数中传入：数组，首尾元素的下表0和n-1
  for (int i = 0; i < n; i++) cout << nums[i] << " ";
  return 0;
}
```

### 对上述图示与代码的解释与模拟

假设有这样一个数组nums

> nums = [5, 4, 3, 2, 1];

选取中间数4作为分割区间的标记数，在初始时，i，j对应的下标分别是-1和4，如下图所示：

![tushi](https://img-blog.csdnimg.cn/20210208110346397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2NDU2Nw==,size_16,color_FFFFFF,,#pic_center,t_70)

经过一次do while语句之后，i，j分别对应0和3，指向数组第一个和最后一个元素。

![tushi](https://img-blog.csdnimg.cn/20210208110422437.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2NDU2Nw==,size_16,color_FFFFFF,#pic_center,t_70)

为了使前一个区间全都小于标记值4，后一个区间全都大于标记值4，我们使i++，直到i对应的值大于或等于标记值4；使j--，直到j对应的值小于或等于值4，之后进行元素值的交换（swap语句）。

通过这一次while循环，可以使得原先数组的前一半部分全部小于或等于标记值4，后一部分全都大于或等于标记值4

把5和1进行交换：

![tushi](https://img-blog.csdnimg.cn/20210208110507501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2NDU2Nw==,size_16,color_FFFFFF,#pic_center,t_70)

交换之后得到：

![tushi](https://img-blog.csdnimg.cn/20210208110537640.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2NDU2Nw==,size_16,color_FFFFFF,#pic_center,t_70)

此时i = 0，j = 3，满足i < j，进入下一次while循环：

再进行两个do-while循环得到:此时i指向4，j指向3，交换值，可以得到：

![tushi](https://img-blog.csdnimg.cn/20210208110606490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2NDU2Nw==,size_16,color_FFFFFF,#pic_center,t_70)

最终经过一次while循环，我们得到了基于标记值4的数组分割：即前面的数字都 <= 4，后面的数字都 >= 4

![tushi](https://img-blog.csdnimg.cn/20210208110636774.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2NDU2Nw==,size_16,color_FFFFFF,#pic_center,t_70)

最后递归的对这两个小区间进行快速排序，即：

```C++
quick_sort(q, l, j);
quick_sort(q,j+1,r);
```

### 算法复杂度分析

平均时间复杂度：O(nlogn)

![tujie](https://img-blog.csdnimg.cn/2021020811074362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzg2NDU2Nw==,size_16,color_FFFFFF,#pic_center,t_70)

最差时间复杂度：O(n*n)

当数组已经排好序的情况下，快速排序退化为冒泡排序。

[参考](https://blog.csdn.net/weixin_43864567/article/details/113753440?spm=1001.2101.3001.6650.15&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-15-113753440-blog-82587933.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-15-113753440-blog-82587933.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=21)

## 归并排序

### 与快排比较

回顾快速排序的基本思想：找出一个分界线，并以该分界线为界将数组分为两部分，再对这两部分以同样的方式分别排序。

但是！**快速排序作为一种高效率的算法，它的缺点在于算法的复杂度很依赖分界线的选取**。因为这决定了左右两边划分的元素个数是否平衡。

那么，我们能不能变通一下，规避这种情况带来的效率损失呢？

回忆快速排序中，正是因为分界线的存在，使得划分到两边的数字排好序后，通过分界线的连接，能够天然形成原序列的排序。但如果我们不设置分界线，而是直接把序列从中间分成相等的两份，然后两边分别排序，我们仍然可以很快地将两个有序序列合并成原序列的有序序列吗？

回顾分治法的内容：

分治思想是一种“分而治之”的思想，反应在解决问题当中，就是将一个复杂问题不断分解为规模更小、更容易解决的问题，从而提升解决问题的效率。而分治法就是基于分治思想得到的解决问题的方法，它分为下面三个步骤：

- 问题的拆分。例如在快速排序中，我们以某个元素为分界线，将待排序的数字分为两部分。

- 解决子问题。例如在快速排序中，如果子问题的规模为1，我们就直接解决它，否则，我们就使用和划分主问题同样的办法继续划分子问题直到子问题规模达到很容易直接解决止。

- 合并子问题的解。例如在快速排序中，我们将左边右边分别排序后，将前后排好序的部分与中间的分界线连接，形成主问题的解。

### 归并排序的算法过程

- 假设我们要对数组a[1..n]排序。初始化左端点l=1，右端点r=n。

- 下面假设我们对l到r子段内的数字进行划分。取l和r的中点mid，将l到mid的元素看成第一个子段的部分，将mid+1到r的部分看成第二个子段的部分。两边分别进入下一层，重复调用上面的过程。直到子段长度为1，返回上一层。

- 当算法阶段返回到当前层时，使用归并操作合并下一层的左右两个有序序列，形成本层的有序序列，继续返回上一层。

- 当整个过程结束以后，整个序列排序完毕。

### 代码实现

```C++
#include <bits/stdc++.h>
# define N 100010
using namespace std;

int n;
int nums[N], temp[N];                                      // 原数组与辅助数组

void merge(int low, int mid, int high) {                   // 传入分好的首尾下标
  int i = low, j = mid + 1, k = low;                       // 两个数组的头指针

  while (i <= mid && j <= high) {
    if (nums[i] < nums[j]) temp[k++] = nums[i++];          // 合并操作
    else temp[k++] = nums[j++];
  }

  while (i <= mid) temp[k++] = nums[i++];                  // 是否有剩余
  while (j <= high) temp[k++] = nums[j++];

  for (int i = low; i <= high; i++) nums[i++] = temp[i++];
}

void mergeSort (int left, int right) {                      // left和right分别代表当前排序子段在原序列中左右端点的位置
  if (l >= r) return;                                       // 当子段为空或者长度为1，说明它已经有序，所以退出该函数
  int mid = l + r >> 1;                                     // 取序列的中间位置，并将序列分成两部分（左右长度相差最多为1）
  mergeSort(left, mid);
  mergeSort(mid + 1, right);
  merge(left, mid, right);                                  // 将l..mid和mid+1..r两个子段合并成完整的l..r的有序序列
}

int main () {
  cin >> n;
  for (int i = 0; i < n; i++) cin >> nums[i];
  mergeSort(1, n);                                          // 传入归并算法的参数与快排不同：下标1和长度n
  for (int j = 0; j < n; j++) cout << nums[i] << " ";
  return 0;
}
```

### 复杂度分析

归并排序，时间复杂度为 O（nlogn）

[](https://blog.csdn.net/DUXS11/article/details/125818272?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-125818272-blog-110346681.pc_relevant_multi_platform_featuressortv2dupreplace&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-125818272-blog-110346681.pc_relevant_multi_platform_featuressortv2dupreplace&utm_relevant_index=1)

## 快排和归并排序的思考

## 从效率上

- 快速排序是二叉树的结构，一般情况下，时间复杂度为o(nlog2n)，在最坏情况（基本有序）下，时间复杂度会达到o(n2)

- 归并排序是倒二叉树结构，在任何情况下时间复杂度都是o(nlog2n)

快速排序建立二叉树的时候，我们会采用随机选择pivot基准的方法。

## 算法原理

- 快速排序对于每一层二叉树，遍历的次数是小于n的，比如说它在第二层就已经确定了一个点的位置，在第三层就已经确定了三个点的位置，在第四层确定了七个点的位置。越向下面的结点遍历，次数越少。

- 归并排序每次都要将n个数据合并，遍历的次数固定为n。

所以，在每一层的遍历，快速排序是比归并排序要高出0-50%的效率的

## 使用快排而不是归排

《算法图解》上说，大致理解了是什么原因，真正的原因是：不可描述的常量导致使用快排而不是归排。

算法的每一步实际上都需要一个固定时间量，被称为常量。我们平时考虑时间复杂度的时候并不考虑常量的影响，但有时候常量的影响不可忽略，比如在这个问题上。但是大多数时候考虑复杂度的时候，可能还是不需要考虑常量的影响的，嗯，我觉得是……由于算法的每一步都有一个常量，而快排的常量比归排小，因此虽然两者的复杂度相同，但是快排更快一些。

那第二个问题就来了，归排的复杂度一直都是O(n*log n)，而快排的平均复杂度才是O(n*log n)，最坏情况下快排的复杂度可以达到O(n^2)，为什不怕快排的时候是最坏的情况呢？主要是因为绝大多数情况下，快排遇到的都是平均情况，也就是最佳情况，只有极个别的时候会是最坏情况，因此往往不考虑这种糟糕的情况。

## 深度理解

归并排序和快速排序是两种稍微复杂的排序算法，它们**用的都是分治的思想**，代码都通过递归来实现，过程非常相似。

- 归并排序算法是一种在任何情况下时间复杂度都比较稳定的排序算法，这也使它存在致命的缺点，**即归并排序不是原地排序算法，空间复杂度比较高，是 O(n)** 。正因为此它也没有快排应用广泛。(快排的空间复杂度为logN);

- 快速排序算法虽然最坏情况下的时间复杂度是 O(n²)，但是平均情况下时间复杂度都是 O(nlogn)。且**快速排序算法时间复杂度退化到 O(n²) 的概率非常小，我们可以通过合理地选择基准值来避免这种情况。**

## 应用时机

- 当对于数据量大，**数据分布高度随机的场景**，快速排序的**平均效率**要高于 堆排序和 归并排序；

- 归并排序适合链表排序但不适合数组排序；归并在外部排序，比如磁盘文件的情况下比快排好，因为快排很依赖数据的随机存取，而**归并是顺序存取，对磁盘这种外存比较友好**

- 快排和堆排都是不稳定排序，**归并排序是稳定排序**。若要求排序稳定，则可以选用归并排序
